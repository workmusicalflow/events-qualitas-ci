{# GSAP pour les animations #}
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

{# Alpine.js pour la gestion d'état #}
<script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('carouselData', () => ({
            currentIndex: 0,
            nextIndex: 1,
            isAnimating: false,
            autoplayInterval: null,
            isPaused: false,
            images: [
                { src: '/images/banner/slider-pic-0.jpg', webp: '/images/banner/slider-pic-0.webp' },
                { src: '/images/banner/slider-pic-1.jpg', webp: '/images/banner/slider-pic-1.webp' },
                { src: '/images/banner/slider-pic-2.jpg', webp: '/images/banner/slider-pic-2.webp' },
                { src: '/images/banner/slider-pic-3.jpg', webp: '/images/banner/slider-pic-3.webp' },
                { src: '/images/banner/slider-pic-4.jpg', webp: '/images/banner/slider-pic-4.webp' }
            ],

            initCarousel() {
                this.preloadImages();
                this.startAutoplay();
                this.setupKeyboardNavigation();
            },

            preloadImages() {
                this.images.forEach(image => {
                    const img = new Image();
                    img.src = image.src;
                    if (image.webp) {
                        const webp = new Image();
                        webp.src = image.webp;
                    }
                });
            },

            setupKeyboardNavigation() {
                this.$watch('$root.matches', value => {
                    if (value) {
                        document.addEventListener('keydown', e => {
                            if (e.key === 'ArrowLeft') this.prev();
                            if (e.key === 'ArrowRight') this.next();
                        });
                    }
                });
            },

            startAutoplay() {
                if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches && !this.isPaused) {
                    this.autoplayInterval = setInterval(() => this.next(), 5000);
                }
            },

            pauseAutoplay() {
                this.isPaused = true;
                if (this.autoplayInterval) {
                    clearInterval(this.autoplayInterval);
                    this.autoplayInterval = null;
                }
            },

            resumeAutoplay() {
                this.isPaused = false;
                this.startAutoplay();
            },

            async transition(direction) {
                if (this.isAnimating) return;
                this.isAnimating = true;

                const currentSlide = this.$refs.currentSlide;
                const nextSlide = this.$refs.nextSlide;
                const xOffset = direction === 'next' ? 100 : -100;

                // Prépare la prochaine slide
                gsap.set(nextSlide, {
                    x: xOffset,
                    opacity: 1,
                    zIndex: 2
                });

                // Animation simultanée des deux slides
                await gsap.timeline({
                    defaults: { duration: 0.8, ease: 'power3.inOut' }
                })
                .to(currentSlide, {
                    x: -xOffset,
                    opacity: 0,
                    zIndex: 1
                })
                .to(nextSlide, {
                    x: 0,
                    zIndex: 2
                }, '<')
                .then(() => {
                    // Reset des positions
                    gsap.set([currentSlide, nextSlide], {
                        clearProps: 'all'
                    });

                    // Mise à jour des indices
                    this.currentIndex = this.nextIndex;
                    this.nextIndex = (this.currentIndex + 1) % this.images.length;
                    this.isAnimating = false;
                });
            },

            async next() {
                this.nextIndex = (this.currentIndex + 1) % this.images.length;
                await this.transition('next');
            },

            async prev() {
                this.nextIndex = (this.currentIndex - 1 + this.images.length) % this.images.length;
                await this.transition('prev');
            },

            async goTo(index) {
                if (this.isAnimating || index === this.currentIndex) return;
                
                this.nextIndex = index;
                const direction = index > this.currentIndex ? 'next' : 'prev';
                await this.transition(direction);
            }
        }));
    });
</script>
